/*
    显式标注

    借用检查器使用显式的生命周期标记来明确引用的有效时间应该持续多久。
    在生命周期没有省略的情况下，Rust 需要显式标注来确定引用的生命周期应该是什么样的。
    可以用撇号`'`显式地标出生命周期，语法如下：
        foo<'a>
        // foo带有一个声明周期参数 `'a`

    和闭包类似，使用生命周期需要`泛型`。
    另外这个生命周期的语法也表明了 foo 的生命周期不能超出'a 的周期。
    若要给`类型`显式地标注生命周期，其语法会像是 &'a T 这样。

        foo<'a,'b>
        // `foo` 带有生命周期参数 `'a` 和 `'b`
    在上面这种情形中，foo 的生命周期不能超出 'a 和 'b 中任意一个周期。
*/

#[cfg(test)]
mod tests {
    // 函数print_refs接受两个 `i32` 的引用，它们有不同的生命周期 `'a` 和 `'b`。
    // 这两个生命周期都必须至少要和print_refs函数一样长。
    fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
        println!("x is {} and y is {}", x, y);
    }

    /*
        上面函数可以直接简写成下面这样：
        fn print_refs(x: &i32, y: &i32) {
            println!("x is {} and y is {}", x, y);
        }
    */

    // 不带参数的函数，不过有一个生命周期参数 `'a`
    fn failed_borrow<'a>() {
        let x = 1024;

        // 编译报错：error[E0597]: `x` does not live long enough
//        let y: &'a i32 = &x;
        // 因为x是在函数内部声明的，它的生命周期一定小于函数的生命周期'a
        // 在函数内部使用生命周期 `'a` 作为显式类型标注将导致失败,
        // 短生命周期不能强制转换成长生命周期。(&x为短生命周期，向长生命周期'a转换)
    }

    #[test]
    fn test_explicit_annotation() {
        let (x, y) = (1024, 2048);

        // 两个变量的借用（`&`）都传进函数
        print_refs(&x,&y);
        // 任何被借用的输入量都必须比借用者生存得更长。
        // 即，x和y的生命周期必须比函数print_refs的生命周期长

        failed_borrow();
        // `failed_borrow` 未包含引用，因此不要求 `'a` 长于函数的生命周期。
        // 但 `'a` 寿命确实更长。因为该生命周期从未被约束，所以默认为 `'static`。
    }
}