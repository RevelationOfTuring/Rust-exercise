/*
    泛型函数：同样的泛型规则也适用于函数：在使用类型 T 前给出 <T>，那么 T 就变成了泛型。

    调用泛型函数有时需要显式地指明类型参量。
    这可能是因为调用了`返回类型`是泛型的函数，或者编译器没有足够的信息来推断类型参数。
*/

//  调用函数时，使用显式指定的类型参数会像是这样：fun::<A, B, ...>()。

#[cfg(test)]
mod tests {
    struct A;

    struct S(A);  // 一个struct tuple

    struct SGen<T>(T);  // 一个带泛型的struct tuple

    // 下面全部函数都得到了变量的所有权，并立即使之离开作用域，将变量释放:

    // 定义一个函数 `func1`，接受一个 `S` 类型的参数 `_s`。
    // 因为没有 `<T>` 这样的泛型类型参数，所以这不是泛型函数。
    fn func1(_s: S) {}

    // 定义一个函数 `func2`，接受一个 `SGen<A>` 类型的参数 `_s`。
    // `SGen<>` 显式地接受了类型参数 `A`，但是在 `func2` 中，`A` 没有被用作
    // 泛型类型参数，所以函数func2不是泛型的。
    fn func2(_s: SGen<A>) {}

    // 定义一个函数 `func3`，接受一个 `SGen<i32>` 类型的参数 `_s`。
    // `SGen<>` 显式地接受了类型参量 `i32`，且 `i32` 是一个具体类型。
    // 由于 `i32` 不是一个泛型类型，所以这个函数也不是泛型的。
    fn func3(_s: SGen<i32>) {}

    // 定义一个函数 `func4`，接受一个 `SGen<T>` 类型的参数 `_s`。
    // 因为 `SGen<T>` 之前有 `<T>`，所以这个函数是关于 `T` 的泛型函数。
    fn func4<T>(_s: SGen<T>) {}
    // 泛型函数需要在函数定义的时候指定泛型类型

    #[test]
    fn test_generics_function() {
        // 使用非泛型函数
        func1(S(A));
        // 隐式地指定类型参数 `A`
        func2(SGen(A));
        // 隐式地指定类型参数 `i32`
        func3(SGen(1024));


        // 为 `func4()` 显式地指定类型参数 `char`
        func4::<char>(SGen('a'));
        // 为 `func4()` 隐式地指定类型参数 `char`。
        func4(SGen('a'));


        // 注：泛型函数的指定是在函数的定义位置，在调用位置上其实是不需要做任何特殊指定的
        // 因为编译器可以隐式指定。
    }
}